/********************************************************************************************************************
 * \file MULTICAN_GW_TX_FIFO.c
 * \copyright Copyright (C) Infineon Technologies AG 2019
 *
 * Use of this file is subject to the terms of use agreed between (i) you or the company in which ordinary course of
 * business you are acting and (ii) Infineon Technologies AG or its licensees. If and as long as no such terms of use
 * are agreed, use of this file is subject to following:
 *
 * Boost Software License - Version 1.0 - August 17th, 2003
 *
 * Permission is hereby granted, free of charge, to any person or organization obtaining a copy of the software and
 * accompanying documentation covered by this license (the "Software") to use, reproduce, display, distribute, execute,
 * and transmit the Software, and to prepare derivative works of the Software, and to permit third-parties to whom the
 * Software is furnished to do so, all subject to the following:
 *
 * The copyright notices in the Software and this entire statement, including the above license grant, this restriction
 * and the following disclaimer, must be included in all copies of the Software, in whole or in part, and all
 * derivative works of the Software, unless such copies or derivative works are solely in the form of
 * machine-executable object code generated by a source language processor.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE
 * WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE, TITLE AND NON-INFRINGEMENT. IN NO EVENT SHALL THE
 * COPYRIGHT HOLDERS OR ANYONE DISTRIBUTING THE SOFTWARE BE LIABLE FOR ANY DAMAGES OR OTHER LIABILITY, WHETHER IN
 * CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS
 * IN THE SOFTWARE.
 *********************************************************************************************************************/

/*********************************************************************************************************************/
/*-----------------------------------------------------Includes------------------------------------------------------*/
/*********************************************************************************************************************/
#include "MULTICAN_GW_TX_FIFO.h"

/*********************************************************************************************************************/
/*-------------------------------------------------Global variables--------------------------------------------------*/
/*********************************************************************************************************************/
multicanType g_multican;
canCommunicationStatusType g_status = CanCommunicationStatus_Success;
IfxPort_Pin_Config g_led1;
uint8 g_currentCanMessage = 0;
volatile uint8 g_isrRxCount = 0;                    /* Declared as volatile in order not to be optimized by compiler */

/*********************************************************************************************************************/
/*--------------------------------------------Private Variables/Constants--------------------------------------------*/
/*********************************************************************************************************************/
const uint32 g_canInitialMessageData[2] = {0xDA7A0000, 0xBA5E0000};

/*********************************************************************************************************************/
/*---------------------------------------------Function Implementations----------------------------------------------*/
/*********************************************************************************************************************/
/* Macro to define Interrupt Service Routine.
 * This macro:
 * - defines linker section as .intvec_tc<vector number>_<interrupt priority>.
 * - defines compiler specific attribute for the interrupt functions.
 * - defines the Interrupt service routine as ISR function.
 *
 * IFX_INTERRUPT(isr, vectabNum, priority)
 *  - isr: Name of the ISR function.
 *  - vectabNum: Vector table number.
 *  - priority: Interrupt priority. Refer Usage of interrupt macro for more details.
 */
IFX_INTERRUPT(canIsrRxHandler, 0, ISR_PRIORITY_CAN_RX);

/* Interrupt Service Routine (ISR) called once the RX interrupt is generated.
 * Reads the received CAN message and in case of no errors, increments the counter to 
 * indicate number of successfully received CAN messages.
 */
void canIsrRxHandler(void)
{
    IfxMultican_Status readStatus;

    /* Read the received CAN message and store the status of the operation */
    readStatus = IfxMultican_Can_MsgObj_readMessage(&g_multican.canDstMsgObj, &g_multican.rxMsg[g_isrRxCount]);

    /* If no new data has been received, report an error */
    if(!(readStatus & IfxMultican_Status_newData))
    {
        g_status = CanCommunicationStatus_Error_noNewDataReceived;
    }

    /* If a new data has been received but with one message lost, report an error */
    if(readStatus == IfxMultican_Status_newDataButOneLost)
    {
        g_status = CanCommunicationStatus_Error_newDataButOneLost;
    }

    /* If there was no error, increment the counter to indicate the number of successfully received CAN messages */
    if(g_status == CanCommunicationStatus_Success)
    {
        g_isrRxCount++;
    }
}

/* Function to initialize MULTICAN module, nodes and message objects related for this application use case */
void initMultican(void)
{
    uint8 currentCanNode;

    /* ==========================================================================================
     * CAN module configuration and initialization:
     * ==========================================================================================
     *  - load default CAN module configuration into configuration structure
     *  - define the interrupt priority for both interrupt node pointers used in the example
     *  - initialize CAN module with the modified configuration
     * ==========================================================================================
     */
    IfxMultican_Can_initModuleConfig(&g_multican.canConfig, &MODULE_CAN);

    g_multican.canConfig.nodePointer[RX_INTERRUPT_SRC_ID].priority = ISR_PRIORITY_CAN_RX;

    IfxMultican_Can_initModule(&g_multican.can, &g_multican.canConfig);

    /* ==========================================================================================
     * Common CAN node configuration and initialization:
     * ==========================================================================================
     *  - load default CAN node configuration into configuration structure
     *  - set CAN node in the "Loop-Back" mode (no external pins will be used)
     * ==========================================================================================
     */
    IfxMultican_Can_Node_initConfig(&g_multican.canNodeConfig, &g_multican.can);

    g_multican.canNodeConfig.loopBackMode = TRUE;

    /* ==========================================================================================
     * CAN node [0...3] configuration and initialization:
     * ==========================================================================================
     *  - assign node to CAN node "currentCanNode"
     *  - initialize the CAN node "currentCanNode" with the modified configuration
     * ==========================================================================================
     */
    for(currentCanNode = 0; currentCanNode < NUMBER_OF_CAN_NODES; currentCanNode++)
    {
        g_multican.canNodeConfig.nodeId = (IfxMultican_NodeId)currentCanNode;

        IfxMultican_Can_Node_init(&g_multican.canNode[currentCanNode], &g_multican.canNodeConfig);
    }

    /* =======================================================================================================
     * Gateway source message object configuration and initialization:
     * =======================================================================================================
     *  - load default CAN message object configuration into configuration structure
     *
     *  - define the message object ID (each message object ID value should be unique)
     *  - define the CAN message ID used during arbitration phase
     *  - define the number of FIFO slave objects that is used as gateway DESTINATION object
     *  - define the message object as a receive message object
     *  - define the first slave object of the FIFO to be the first message object after TX FIFO base object
     *
     *  - enable gateway transfers (will define this message object as gateway source object)
     *  - copy data length code of the gateway source object to a gateway destination object
     *  - copy data content of the gateway source object to a gateway destination object
     *  - do NOT copy identifier (ID) of the gateway source object to a gateway destination object
     *  - enable setting TXRQ bit in the gateway destination object
     *  - define the first slave object of the FIFO as the gateway destination object
     *
     *  - initialize the gateway source CAN message object with the modified configuration
     * -------------------------------------------------------------------------------------------------------
     * This CAN message object is assigned to CAN Node 0
     * =======================================================================================================
     */
    IfxMultican_Can_MsgObj_initConfig(&g_multican.canMsgObjConfig, &g_multican.canNode[0]);

    g_multican.canMsgObjConfig.msgObjId = GTW_SRC_MESSAGE_OBJECT_ID;
    g_multican.canMsgObjConfig.messageId = GTW_SRC_MESSAGE_ID;
    g_multican.canMsgObjConfig.msgObjCount = TX_FIFO_SIZE;
    g_multican.canMsgObjConfig.frame = IfxMultican_Frame_receive;
    g_multican.canMsgObjConfig.firstSlaveObjId = SLAVE_MESSAGE_OBJECT_ID;

    g_multican.canMsgObjConfig.gatewayTransfers = TRUE;
    g_multican.canMsgObjConfig.gatewayConfig.copyDataLengthCode = TRUE;
    g_multican.canMsgObjConfig.gatewayConfig.copyData = TRUE;
    g_multican.canMsgObjConfig.gatewayConfig.copyId = FALSE;
    g_multican.canMsgObjConfig.gatewayConfig.enableTransmit = TRUE;
    g_multican.canMsgObjConfig.gatewayConfig.gatewayDstObjId = SLAVE_MESSAGE_OBJECT_ID;

    IfxMultican_Can_MsgObj_init(&g_multican.canGtwSrcMsgObj, &g_multican.canMsgObjConfig);

    /* =======================================================================================================
     * Gateway destination (implemented as TX FIFO object) configuration and initialization:
     * =======================================================================================================
     *  - load default CAN message object configuration into configuration structure
     *
     *  - define the message object ID for the TX FIFO base object (each message object ID value should be unique)
     *  - define the CAN message ID used during arbitration phase (different than the ID used for source MO)
     *  - define the number of FIFO slave objects
     *  - define the message object as a transmit message object (TX FIFO in this case)
     *  - define the first slave object of the FIFO to be the first message object after TX FIFO base object
     *
     *  - initialize the gateway destination CAN message object with the modified configuration
     * -------------------------------------------------------------------------------------------------------
     * This CAN message object is assigned to CAN Node 1
     * =======================================================================================================
     */
    IfxMultican_Can_MsgObj_initConfig(&g_multican.canMsgObjConfig, &g_multican.canNode[1]);

    g_multican.canMsgObjConfig.msgObjId = GTW_DST_MESSAGE_OBJECT_ID;
    g_multican.canMsgObjConfig.messageId = GTW_DST_MESSAGE_ID;
    g_multican.canMsgObjConfig.msgObjCount = TX_FIFO_SIZE;
    g_multican.canMsgObjConfig.frame = IfxMultican_Frame_transmit;
    g_multican.canMsgObjConfig.firstSlaveObjId = SLAVE_MESSAGE_OBJECT_ID;

    IfxMultican_Can_MsgObj_init(&g_multican.canGtwDstMsgObj, &g_multican.canMsgObjConfig);

    /* =======================================================================================================
     * Source standard message object configuration and initialization:
     * =======================================================================================================
     *  - load default CAN message object configuration into configuration structure
     *
     *  - define the message object ID (each message object ID value should be unique)
     *  - define the CAN message ID used during arbitration phase (same as ID used for gateway source MO)
     *  - define the message object as a transmit message object
     *
     *  - initialize the source standard CAN message object with the modified configuration
     * -------------------------------------------------------------------------------------------------------
     * This CAN message object is assigned to CAN Node 2
     * =======================================================================================================
     */
    IfxMultican_Can_MsgObj_initConfig(&g_multican.canMsgObjConfig, &g_multican.canNode[2]);

    g_multican.canMsgObjConfig.msgObjId = SRC_MESSAGE_OBJECT_ID;
    g_multican.canMsgObjConfig.messageId = SRC_MESSAGE_ID;
    g_multican.canMsgObjConfig.frame = IfxMultican_Frame_transmit;

    IfxMultican_Can_MsgObj_init(&g_multican.canSrcMsgObj, &g_multican.canMsgObjConfig);

    /* =======================================================================================================
     * Destination standard message object configuration and initialization:
     * =======================================================================================================
     *  - load default CAN message object configuration into configuration structure
     *
     *  - define the message object ID (different than the ID used for source MO)
     *  - define the CAN message ID used during arbitration phase (same as ID used for gateway destination MO)
     *  - define the message object as a receive message object
     *  - enable interrupt generation in case of CAN message reception
     *  - define interrupt node pointer to be used
     *
     *  - initialize the destination standard CAN message object with the modified configuration
     * -------------------------------------------------------------------------------------------------------
     * This CAN message object is assigned to CAN Node 3
     * =======================================================================================================
     */
    IfxMultican_Can_MsgObj_initConfig(&g_multican.canMsgObjConfig, &g_multican.canNode[3]);

    g_multican.canMsgObjConfig.msgObjId = DST_MESSAGE_OBJECT_ID;
    g_multican.canMsgObjConfig.messageId = DST_MESSAGE_ID;
    g_multican.canMsgObjConfig.frame = IfxMultican_Frame_receive;
    g_multican.canMsgObjConfig.rxInterrupt.enabled = TRUE;
    g_multican.canMsgObjConfig.rxInterrupt.srcId = RX_INTERRUPT_SRC_ID;

    IfxMultican_Can_MsgObj_init(&g_multican.canDstMsgObj, &g_multican.canMsgObjConfig);
}

/* Function to initialize and transmit CAN messages.
 * Before a CAN message is transmitted, a number of CAN messages need to be initialized.
 * The user can change the number of CAN messages by modifying NUMBER_OF_CAN_MESSAGES macro value.
 * The TX messages (messages that are transmitted) are initialized with the combination of predefined
 * content and current CAN message value. The RX messages (messages where the received CAN data is stored)
 * are initialized with invalid ID, data and length value (after successful CAN transmission,
 * the values are replaced with the valid content). After each CAN message transmission, a code execution waits
 * until the received data has been read by the interrupt service routine.
 */
void transmitCanMessages(void)
{
    /* Invalidation of the RX messages */
    for(g_currentCanMessage = 0; g_currentCanMessage < NUMBER_OF_CAN_MESSAGES; g_currentCanMessage++)
    {
        IfxMultican_Message_init(&g_multican.rxMsg[g_currentCanMessage],
                                 INVALID_ID_VALUE,
                                 INVALID_DATA_VALUE,
                                 INVALID_DATA_VALUE,
                                 INVALID_LENGTH_VALUE);
    }

    for(g_currentCanMessage = 0; g_currentCanMessage < NUMBER_OF_CAN_MESSAGES; g_currentCanMessage++)
    {
        /* Initialization of the TX message */
        IfxMultican_Message_init(&g_multican.txMsg,
                                 SRC_MESSAGE_ID,
                                 ( g_canInitialMessageData[0] | g_currentCanMessage ),
                                 ( g_canInitialMessageData[1] | g_currentCanMessage ),
                                 g_multican.canMsgObjConfig.control.messageLen);

        /* Send the CAN message with the previously defined TX message content */
        while(IfxMultican_Status_notSentBusy ==
           IfxMultican_Can_MsgObj_sendMessage(&g_multican.canSrcMsgObj, &g_multican.txMsg))
        {
        }

        /* Wait until previously transmitted data has been received in the destination message object
         * and no error has been detected. If the code execution stops at this point, check the "g_status" variable.
         */
        while(g_isrRxCount == g_currentCanMessage)
        {
        }
    }
}

/* Function to verify CAN messages.
 * After all the expected messages have been received, several checks are performed.
 * The current CUR pointer of the gateway source object is compared against expected CUR pointer value.
 * Similarly, the value of the gateway destination object (TX FIFO base object) is also checked.
 * Finally, the received data is compared to expected data and LED1 is turned on to indicate successful usage of
 * gateway and FIFO functionality of MultiCAN+ module.
 */
void verifyCanMessages(void)
{
    Ifx_CAN_MO *hwObj;

    /* Get the pointer to the gateway source object. */
    hwObj = IfxMultican_MsgObj_getPointer(g_multican.can.mcan, GTW_SRC_MESSAGE_OBJECT_ID);

    /* Check if the CUR value does not match with the expected data in the gateway source object.
     * If this is the case, an error should be reported.
     */
    if(EXPECTED_CUR_POINTER_VALUE != hwObj->FGPR.B.CUR)
    {
        g_status = CanCommunicationStatus_Error_notExpectedFifoCurPointer;
    }

    /* Get the pointer to the gateway destination (TX FIFO base) object */
    hwObj = IfxMultican_MsgObj_getPointer(g_multican.can.mcan, GTW_DST_MESSAGE_OBJECT_ID);

    /* Check if the CUR value does not match with the expected data in the gateway destination object.
     * If this is the case, an error should be reported.
     */
    if(EXPECTED_CUR_POINTER_VALUE != hwObj->FGPR.B.CUR)
    {
        g_status = CanCommunicationStatus_Error_notExpectedFifoCurPointer;
    }

    for(g_currentCanMessage = 0; g_currentCanMessage < NUMBER_OF_CAN_MESSAGES; g_currentCanMessage++)
    {
        /* Check if the received message ID matches with the transmitted message ID.
         * If this is the case, an error should be reported. Source standard message object and destination
         * standard message object have different message ID configuration.
         */
        if(g_multican.rxMsg[g_currentCanMessage].id == SRC_MESSAGE_ID)
        {
            g_status = CanCommunicationStatus_Error_notExpectedMessageId;
            break;
        }

        /* Check if the received message length does NOT match with the expected message length.
         * If this is the case, an error should be reported.
         */
        if(g_multican.rxMsg[g_currentCanMessage].lengthCode != g_multican.canMsgObjConfig.control.messageLen)
        {
            g_status = CanCommunicationStatus_Error_notExpectedLengthCode;
            break;
        }

        /* Finally, check if a received data does NOT match with the transmitted one
         * If this is the case, an error should be reported.
         */
        if((g_multican.rxMsg[g_currentCanMessage].data[0] != (g_canInitialMessageData[0] | g_currentCanMessage)) ||
            (g_multican.rxMsg[g_currentCanMessage].data[1] != (g_canInitialMessageData[1] | g_currentCanMessage)))
        {
            g_status = CanCommunicationStatus_Error_notExpectedData;
            break;
        }
    }

    /* If there was no error, turn on the LED1 to indicate correctness of the received messages */
    if(g_status == CanCommunicationStatus_Success)
    {
        IfxPort_setPinLow(g_led1.port, g_led1.pinIndex);
    }
}

/* Function to initialize pin that is connected to the LED */
void initLed(void)
{
    /* ======================================================================
     * Configuration of the pin connected to the LED:
     * ======================================================================
     *  - define the GPIO port
     *  - define the GPIO pin that is the connected to the LED
     *  - define the general GPIO pin usage (no alternate function used)
     *  - define the pad driver strength
     * ======================================================================
     */
    g_led1.port      = &MODULE_P00;
    g_led1.pinIndex  = PIN5;
    g_led1.mode      = IfxPort_OutputIdx_general;
    g_led1.padDriver = IfxPort_PadDriver_cmosAutomotiveSpeed1;

    /* Initialize the pin connected to the LED to level "HIGH"; will keep the LED turned off as default state */
    IfxPort_setPinHigh(g_led1.port, g_led1.pinIndex);

    /* Set the pin to output push-pull mode */
    IfxPort_setPinModeOutput(g_led1.port, g_led1.pinIndex, IfxPort_OutputMode_pushPull, g_led1.mode);

    /* Set the pad driver mode for a pin */
    IfxPort_setPinPadDriver(g_led1.port, g_led1.pinIndex, g_led1.padDriver);
}
